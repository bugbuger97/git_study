<커밋 병합>
스쿼싱은 여러 commit을 단일 commit으로 병합하는 프로세스임.
git merge를 실행하고 --squash 옵션을 사용하면 새 commit이 브랜치의 모든 커밋을 함께 그룹화함.
그러면 해당 commit이 현재 브랜치에 병합될 수 있음.
git merge --squash를 사용하여 기능 / 주제 브랜치의 commit을 현재 브랜치에 병합할 단일 commit으로 통합함.

<브랜치>
협업 환경에서는 여러 개발자가 동일한 소스 코드를 공유하고 작업하는 것이 일반적임.
여기서 많은 일이 진행됨에 따라 동일한 코드 베이스의 여러 버전을 관리하기 위한 시스템이 필요함.
브랜치를 통해 개발자는 원래 코드를 기반에서 브랜치하고 작업을 다른 사람과 분리할 수 있음.
또한 git이 나중에 버전을 쉽게 병합하는데 도움이 됨.

<git 브랜치>
git 브랜치는 본질적으로 독립적인 개발 라인임.
새 기능이나 버그 수정 작업을 할 때, 브랜치를 사용하여 다른 팀 구성원의 작업과 분리할 수 있음.
별도의 브랜치를 하나의 브랜치로 병합할 수 있음.
기본 또는 기타 브랜치의 변경 사항은 해당 브랜치에서 최신 변경 사항을 가져오지 않는 한 해당 브랜치에 영향을 미치치 않음.

<브랜치 만들기>
새 브랜치를 생성해도 저장소는 변경되지 않음. (단순히 commit을 가리킴)
ex) git branch을 사용하여 issue1이라는 브랜치를 생성하면, 저장소는 동일하게 유지되지만 현재 commit에 대한 새 포인터를 추가함.

<브랜치 전환>
git checkout은 전환하려는 브랜치에 저장된 버전과 일치하도록 작업 트리의 파일을 업데이트 함.
다른 작업 공간 간에 전환하는 방법으로 생각할 수 있음.

<브랜치 가리키기>
HEAD는 브랜치의 현재 스냅샷을 나타내는 데 사용됨.
새 저장소의 경우, git은 기본적으로 HEAD가 메인 브랜치를 가리킴.
HEAD가 가리키는 위치를 변경하려면 활성 브랜치가 업데이트 됨.
~(틸드)와 ^(캐럿) 기호는 특정 commit과 관련된 위치를 가리킴.
기호는 일반적으로 HEAD 또는 커밋 해시와 같은 커밋 참조와 함께 사용됨.

~(틸드) : 조상을 나타냄. (몇 세대 전의 세대는 숫자에 따라 다름.)
HEAD~1 : 커밋의 첫 번째 부모를 나타냄.
HEAD~2 : 커밋의 첫 번째 조부모를 나타냄.
^(캐럿) : 병합 커밋의 부모를 나타냄.
HEAD^1 : 헤드가 병합 커밋인 HEAD의 첫 번째 부모를 나타냄.
HEAD^2 : 헤드가 병합 커밋인 HEAD의 첫 번째 조부모를 나타냄.
커밋은 병합 커밋에서 두 개의 부모를 가질 수 있음. 

<브랜치 보관>
작업 트리에 커밋되지 않은 변경 사항 또는 새 파일이 추가됨이 있고 새 브랜치로 전환하려는 경우,
커밋되지 않은 변경 사항도 새 브랜치로 전달됨. 
커밋한 변경 사항은 새 브랜치에 커밋됨.

git이 현재 브랜치의 커밋되지 않은 변경 사항과 전환하려는 새 브랜치의 파일 간에 충돌을 발견하면,
전환이 허용되지 않음. 
브랜치를 전환하기 전에 해당 변경 사항을 커밋하거나 숨겨야 함.

커밋 되지 않은 변경 사항을 임시로 저장하기 위한 서랍으로 stash를 생각할 수 있음.
스태싱(stashing)을 사용하면 작업 트리에서 지저분한 변경 사항을 제쳐두고 클린 슬레이트로 새 브랜치에서 작업을 계속할 수 있음.
언제든지 stash에 저장된 커밋되지 않은 변경 사항을 꺼내 원래 브랜치 및 다른 브랜치에 나중에 적용할 수 있음.
 
<원격 브랜치>
git은 컴퓨터의 로컬이지만 저장소의 원격 복사본을 가질 수도 있음.
Backlog와 같은 버전 제어 소프트웨어를 사용하여 원격 저장소를 호스팅할 수도 있음.
저장소에 대한 다른 사람의 변경 사항을 검색하거나 저장소의 로컬 복사본을 원격 서버로 이동할 수 있음.
 
<원격 브랜치 풀링>
git pull을 사용하여 원격 저장소의 최신 변경 사항을 로컬 저장소에 적용할 수 있음.
ex) 원격 브랜치가 로컬 브랜치의 업스트림이라고 가정하면, 원격 브랜치에는 로컬 브랜치의 모든 변경 사항이 포함됨.
A -> B -> X -> Y (origin/main : 원격 브랜치)
A -> B (main : 로컬 브랜치)
(원격 브랜치는 로컬 브랜치의 업스트림임.)
이 경우, 원격 브랜치(origin/main)에서 로컬 브랜치(main)로 병합을 적용한다면, fast-forward 병합이 됨.

A -> B -> X -> Y (origin/main : 원격 브랜치), (main : 로컬 브랜치)
로컬 메인 브랜치의 변경 사항이 원격 origin/main 브랜치에 없는 경우, pull 명령은 병합을 실행하고 이러한 변경 사항을 함께 묶는 병합 커밋을 생성함.
git은 로컬 브랜치가 원격 브랜치와 다른 경우 풀링하기 전에 병합 및 커밋해야 함.

풀링을 실행할 때, 로컬 저장소에 병합 커밋이 자동으로 생성됨. 
충돌이 있는 경우, 충돌을 해결하고 병합을 수동으로 커밋해야 함.
충돌이 없으면 커밋이 자동으로 병합됨.

<원격 브랜치 가져오기>
원격 브랜치의 변경 사항은 충돌이 없는 한 풀링을 실행할 때, 현재 로컬 브랜치에 자동으로 병합됨.
원격 변경 사항을 얻고 싶지만, 현재 로컬 브랜치에 병합하지 않으려면, git fetch을 실행할 수 있음.
 
Fetch는 로컬 브랜치에 아직 존재하지 않는 변경 사항을 원격에서 다운로드 함.
FETCH_HEAD ref는 원격 저장소에서 가져온 변경 사항을 추적함.

변경 사항을 가져오면 FETCH_HEAD에서 병합하거나 풀링을 실행하여 해당 변경 사항을 로컬 저장소에 적용할 수 있음.

FETCH_HEAD가 병합되면 개정 기록은 git pull 작업과 동일한 결과를 생성함. 풀링은 가져오기 및 병합 작업을 동시에 실행하는 것임.

<브랜치를 원격으로 푸시>
로컬 브랜치를 원격 저장소로 푸시할 때까지 모든 커밋을 사용할 수 있음.
즉, 다른 팀 구성원에게 영향을 주지 않고 원하는 속도로 로컬 브랜치에서 작업할 수 있음.

로컬 브랜치를 원격으로 푸시하면 git은 대상 저장소에 빨리 병합함.

푸시로 인해 non-fast-forward 병합이 발생하면 git은 이전 커밋을 덮어쓰는 것을 방지하기 위해 푸시를 거부함.
이 경우 최신 원격 변경 사항을 풀링하고 다시 푸시해야 함.
git push를 사용하여 로컬 변경 사항을 원격 저장소에 추가함.

원격 저장소에 이미 커밋을 덮어쓰거나 변경해서는 안됨. 그렇게 하면 다른 팀원의 로컬 저장소가 원격 저장소와 갈라지게 됨.